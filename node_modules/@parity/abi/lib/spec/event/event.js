'use strict';var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}} // Copyright 2015-2017 Parity Technologies (UK) Ltd.
// This file is part of Parity.

// Parity is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity.  If not, see <http://www.gnu.org/licenses/>.

var Decoder = require('../../decoder/decoder');
var DecodedLog = require('./decodedLog');
var DecodedLogParam = require('./decodedLogParam');
var EventParam = require('./eventParam');var _require =
require('../../util/sliceAs'),asAddress = _require.asAddress;var _require2 =
require('../../util/signature'),eventSignature = _require2.eventSignature;var

Event = function () {
  function Event(abi) {_classCallCheck(this, Event);
    this._inputs = EventParam.toEventParams(abi.inputs || []);
    this._anonymous = !!abi.anonymous;var _eventSignature =

    eventSignature(abi.name, this.inputParamTypes()),id = _eventSignature.id,name = _eventSignature.name,signature = _eventSignature.signature;

    this._id = id;
    this._name = name;
    this._signature = signature;
  }_createClass(Event, [{ key: 'inputParamTypes', value: function inputParamTypes()





















    {
      return this._inputs.map(function (input) {return input.kind;});
    } }, { key: 'inputParamNames', value: function inputParamNames()

    {
      return this._inputs.map(function (input) {return input.name;});
    } }, { key: 'indexedParams', value: function indexedParams(

    indexed) {
      return this._inputs.filter(function (input) {return input.indexed === indexed;});
    } }, { key: 'decodeLog', value: function decodeLog(

    topics, data) {
      var topicParams = this.indexedParams(true);
      var dataParams = this.indexedParams(false);

      var address = void 0;
      var toSkip = void 0;

      if (!this.anonymous) {
        address = asAddress(topics[0]);
        toSkip = 1;
      } else {
        toSkip = 0;
      }

      var topicTypes = topicParams.map(function (param) {return param.kind;});
      var flatTopics = topics.
      filter(function (topic, index) {return index >= toSkip;}).
      map(function (topic) {
        return topic.substr(0, 2) === '0x' ?
        topic.substr(2) :
        topic;
      }).join('');
      var topicTokens = Decoder.decode(topicTypes, flatTopics);

      if (topicTokens.length !== topics.length - toSkip) {
        throw new Error('Invalid topic data');
      }

      var dataTypes = dataParams.map(function (param) {return param.kind;});
      var dataTokens = Decoder.decode(dataTypes, data);

      var namedTokens = {};

      topicParams.forEach(function (param, index) {
        namedTokens[param.name || index] = topicTokens[index];
      });
      dataParams.forEach(function (param, index) {
        namedTokens[param.name || index] = dataTokens[index];
      });

      var inputParamTypes = this.inputParamTypes();
      var decodedParams = this.inputParamNames().
      map(function (name, index) {return new DecodedLogParam(name, inputParamTypes[index], namedTokens[name || index]);});

      return new DecodedLog(decodedParams, address);
    } }, { key: 'anonymous', get: function get() {return this._anonymous;} }, { key: 'id', get: function get() {return this._id;} }, { key: 'inputs', get: function get() {return this._inputs;} }, { key: 'name', get: function get() {return this._name;} }, { key: 'signature', get: function get() {return this._signature;} }]);return Event;}();


module.exports = Event;
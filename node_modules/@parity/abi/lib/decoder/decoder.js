'use strict';function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}} // Copyright 2015-2017 Parity Technologies (UK) Ltd.
// This file is part of Parity.

// Parity is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity.  If not, see <http://www.gnu.org/licenses/>.

var utf8 = require('utf8');

var Token = require('../token/token');
var BytesTaken = require('./bytesTaken');
var DecodeResult = require('./decodeResult');
var ParamType = require('../spec/paramType/paramType');var _require =
require('../util/slice'),sliceData = _require.sliceData;var _require2 =
require('../util/sliceAs'),asAddress = _require2.asAddress,asBool = _require2.asBool,asI32 = _require2.asI32,asU32 = _require2.asU32;var _require3 =
require('../util/types'),isArray = _require3.isArray,isInstanceOf = _require3.isInstanceOf;

var NULL = '0000000000000000000000000000000000000000000000000000000000000000';var

Decoder = function Decoder() {_classCallCheck(this, Decoder);};


Decoder.decode = function (params, data) {
  if (!isArray(params)) {
    throw new Error('Parameters should be array of ParamType');
  }

  var slices = sliceData(data);
  var offset = 0;

  return params.map(function (param) {
    var result = Decoder.decodeParam(param, slices, offset);

    offset = result.newOffset;
    return result.token;
  });
};

Decoder.peek = function (slices, position) {
  if (!slices || !slices[position]) {
    return NULL;
  }

  return slices[position];
};

Decoder.takeBytes = function (slices, position, length) {
  var slicesLength = Math.floor((length + 31) / 32);
  var bytesStr = '';

  for (var index = 0; index < slicesLength; index++) {
    bytesStr = '' + bytesStr + Decoder.peek(slices, position + index);
  }

  var bytes = (bytesStr.substr(0, length * 2).match(/.{1,2}/g) || []).map(function (code) {return parseInt(code, 16);});

  return new BytesTaken(bytes, position + slicesLength);
};

Decoder.decodeParam = function (param, slices, offset) {
  if (!isInstanceOf(param, ParamType)) {
    throw new Error('param should be instanceof ParamType');
  }

  var tokens = [];
  var taken = void 0;
  var lengthOffset = void 0;
  var length = void 0;
  var newOffset = void 0;

  switch (param.type) {
    case 'address':
      return new DecodeResult(new Token(param.type, asAddress(Decoder.peek(slices, offset))), offset + 1);

    case 'bool':
      return new DecodeResult(new Token(param.type, asBool(Decoder.peek(slices, offset))), offset + 1);

    case 'int':
      return new DecodeResult(new Token(param.type, asI32(Decoder.peek(slices, offset))), offset + 1);

    case 'uint':
      return new DecodeResult(new Token(param.type, asU32(Decoder.peek(slices, offset))), offset + 1);

    case 'fixedBytes':
      taken = Decoder.takeBytes(slices, offset, param.length);

      return new DecodeResult(new Token(param.type, taken.bytes), taken.newOffset);

    case 'bytes':
      lengthOffset = asU32(Decoder.peek(slices, offset)).div(32).toNumber();
      length = asU32(Decoder.peek(slices, lengthOffset)).toNumber();
      taken = Decoder.takeBytes(slices, lengthOffset + 1, length);

      return new DecodeResult(new Token(param.type, taken.bytes), offset + 1);

    case 'string':
      if (param.indexed) {
        taken = Decoder.takeBytes(slices, offset, 32);

        return new DecodeResult(new Token('fixedBytes', taken.bytes), offset + 1);
      }

      lengthOffset = asU32(Decoder.peek(slices, offset)).div(32).toNumber();
      length = asU32(Decoder.peek(slices, lengthOffset)).toNumber();
      taken = Decoder.takeBytes(slices, lengthOffset + 1, length);

      var str = taken.bytes.map(function (code) {return String.fromCharCode(code);}).join('');

      var decoded = void 0;

      try {
        decoded = utf8.decode(str);
      } catch (error) {
        decoded = str;
      }

      return new DecodeResult(new Token(param.type, decoded), offset + 1);

    case 'array':
      lengthOffset = asU32(Decoder.peek(slices, offset)).div(32).toNumber();
      length = asU32(Decoder.peek(slices, lengthOffset)).toNumber();
      newOffset = lengthOffset + 1;

      for (var index = 0; index < length; index++) {
        var result = Decoder.decodeParam(param.subtype, slices, newOffset);

        newOffset = result.newOffset;
        tokens.push(result.token);
      }

      return new DecodeResult(new Token(param.type, tokens), offset + 1);

    case 'fixedArray':
      newOffset = offset;

      for (var _index = 0; _index < param.length; _index++) {
        var _result = Decoder.decodeParam(param.subtype, slices, newOffset);

        newOffset = _result.newOffset;
        tokens.push(_result.token);
      }

      return new DecodeResult(new Token(param.type, tokens), newOffset);

    default:
      throw new Error('Invalid param type ' + param.type + ' in decodeParam');}

};

module.exports = Decoder;
'use strict';var _slicedToArray = function () {function sliceIterator(arr, i) {var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"]) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}return function (arr, i) {if (Array.isArray(arr)) {return arr;} else if (Symbol.iterator in Object(arr)) {return sliceIterator(arr, i);} else {throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}} // Copyright 2015-2017 Parity Technologies (UK) Ltd.
// This file is part of Parity.

// Parity is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity.  If not, see <http://www.gnu.org/licenses/>.
var _require =
require('../util/types'),isError = _require.isError;

var Eth = require('./eth');
var Logging = require('./logging');
var Personal = require('./personal');
var Signer = require('./signer');

var events = {
  'logging': { module: 'logging' },
  'eth_blockNumber': { module: 'eth' },
  'parity_accountsInfo': { module: 'personal' },
  'parity_allAccountsInfo': { module: 'personal' },
  'parity_defaultAccount': { module: 'personal' },
  'parity_postTransaction': { module: 'signer' },
  'eth_accounts': { module: 'personal' },
  'signer_requestsToConfirm': { module: 'signer' } };var


Manager = function () {
  function Manager(api) {var _this = this;_classCallCheck(this, Manager);
    this._api = api;

    this.subscriptions = [];
    this.values = {};

    Object.keys(events).forEach(function (subscriptionName) {
      _this.values[subscriptionName] = {
        error: null,
        data: null };

    });

    // in the case of a pubsub compliant, don't use the engines
    if (this._api.isPubSub) {
      return;
    }

    this._updateSubscriptions = this._updateSubscriptions.bind(this);

    this._logging = new Logging(this._updateSubscriptions);
    this._eth = new Eth(this._updateSubscriptions, api);
    this._personal = new Personal(this._updateSubscriptions, api, this);
    this._signer = new Signer(this._updateSubscriptions, api, this);
  }_createClass(Manager, [{ key: '_validateType', value: function _validateType(

    subscriptionName) {
      var subscription = events[subscriptionName];

      if (!subscription) {
        return new Error(subscriptionName + ' is not a valid interface, subscribe using one of ' + Object.keys(events).join(', '));
      }

      return subscription;
    } }, { key: 'subscribe', value: function subscribe(

    subscriptionName, callback) {var _this2 = this;var autoRemove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return new Promise(function (resolve, reject) {
        var subscription = _this2._validateType(subscriptionName);

        if (isError(subscription)) {
          reject(subscription);
          return;
        }

        // use normal pub-sub as available
        if (_this2._api.isPubSub) {
          try {var _subscriptionName$spl =
            subscriptionName.split('_'),_subscriptionName$spl2 = _slicedToArray(_subscriptionName$spl, 2),fnSection = _subscriptionName$spl2[0],fnName = _subscriptionName$spl2[1];

            resolve(_this2._api.pubsub[fnSection][fnName](callback));
          } catch (error) {
            console.error('Unable to find subscriptionName', subscriptionName);
            reject(error);
          }

          return;
        }

        var subscriptionId = _this2.subscriptions.length;var _values$subscriptionN =
        _this2.values[subscriptionName],error = _values$subscriptionN.error,data = _values$subscriptionN.data;
        var engine = _this2['_' + subscription.module];

        _this2.subscriptions[subscriptionId] = {
          name: subscriptionName,
          id: subscriptionId,
          autoRemove: autoRemove,
          callback: callback };


        if (!engine.isStarted) {
          engine.start();
        } else if (error !== null || data !== null) {
          _this2._sendData(subscriptionId, error, data);
        }

        resolve(subscriptionId);
      });
    } }, { key: 'unsubscribe', value: function unsubscribe(

    subscriptionId) {var _this3 = this;
      if (this._api.isPubSub) {
        return this._api.pubsub.unsubscribe(subscriptionId);
      }

      return new Promise(function (resolve, reject) {
        if (!_this3.subscriptions[subscriptionId]) {
          reject(new Error('Cannot find subscription ' + subscriptionId));
          return;
        }

        delete _this3.subscriptions[subscriptionId];
        resolve();
      });
    } }, { key: '_sendData', value: function _sendData(

    subscriptionId, error, data) {var _subscriptions$subscr =
      this.subscriptions[subscriptionId],autoRemove = _subscriptions$subscr.autoRemove,callback = _subscriptions$subscr.callback;
      var result = true;

      try {
        result = callback(error, data);
      } catch (error) {
        console.error('Unable to update callback for subscriptionId ' + subscriptionId, error);
      }

      if (autoRemove && result && typeof result === 'boolean') {
        this.unsubscribe(subscriptionId);
      }
    } }, { key: '_updateSubscriptions', value: function _updateSubscriptions(

    subscriptionName, error, data) {var _this4 = this;
      var subscriptions = this.subscriptions.
      filter(function (subscription) {return subscription.name === subscriptionName;});

      this.values[subscriptionName] = { error: error, data: data };

      subscriptions.
      forEach(function (subscription) {
        _this4._sendData(subscription.id, error, data);
      });
    } }]);return Manager;}();


Manager.events = events;

module.exports = Manager;
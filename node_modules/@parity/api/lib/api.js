'use strict';var _slicedToArray = function () {function sliceIterator(arr, i) {var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"]) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}return function (arr, i) {if (Array.isArray(arr)) {return arr;} else if (Symbol.iterator in Object(arr)) {return sliceIterator(arr, i);} else {throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self, call) {if (!self) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call && (typeof call === "object" || typeof call === "function") ? call : self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;} // Copyright 2015-2017 Parity Technologies (UK) Ltd.
// This file is part of Parity.

// Parity is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity.  If not, see <http://www.gnu.org/licenses/>.

var EventEmitter = require('eventemitter3');

var Contract = require('./contract');
var Providers = require('./provider');
var Transports = require('./transport');var _require =

require('./rpc'),Db = _require.Db,Eth = _require.Eth,Parity = _require.Parity,Net = _require.Net,Personal = _require.Personal,Shell = _require.Shell,Shh = _require.Shh,Signer = _require.Signer,Trace = _require.Trace,Web3 = _require.Web3;
var Subscriptions = require('./subscriptions');
var Pubsub = require('./pubsub');
var util = require('./util');var _require2 =
require('./util/types'),isFunction = _require2.isFunction;var

Api = function (_EventEmitter) {_inherits(Api, _EventEmitter);
  function Api(provider) {var allowSubscriptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var middlewareClass = arguments[2];_classCallCheck(this, Api);var _this = _possibleConstructorReturn(this, (Api.__proto__ || Object.getPrototypeOf(Api)).call(this));


    if (!provider) {
      throw new Error('Provider needs to be supplied to Api instance');
    }

    if (isFunction(provider.sendAsync)) {
      provider = new Providers.Current(provider);
    } else if (!isFunction(provider.send)) {
      console.warn(new Error('deprecated: Api needs provider with send() function, old-style Transport found instead'), provider);
    }

    _this._provider = new Providers.PromiseProvider(provider);
    _this._provider.on('connected', function () {return _this.emit('connected');});
    _this._provider.on('connecting', function () {return _this.emit('connecting');});
    _this._provider.on('disconnected', function () {return _this.emit('disconnected');});

    _this._db = new Db(_this._provider);
    _this._eth = new Eth(_this._provider);
    _this._net = new Net(_this._provider);
    _this._parity = new Parity(_this._provider);
    _this._personal = new Personal(_this._provider);
    _this._shell = new Shell(_this._provider);
    _this._shh = new Shh(_this._provider);
    _this._signer = new Signer(_this._provider);
    _this._trace = new Trace(_this._provider);
    _this._web3 = new Web3(_this._provider);

    // FIXME: Remove, convert to shell
    if (middlewareClass) {
      var middleware = _this.parity.
      nodeKind().
      then(function (nodeKind) {
        if (nodeKind.availability === 'public') {
          return middlewareClass;
        }

        return null;
      }).
      catch(function () {return null;});

      provider.addMiddleware(middleware);
    }

    if (provider && isFunction(provider.subscribe)) {
      _this._pubsub = new Pubsub(provider);
    }

    if (allowSubscriptions) {
      _this._subscriptions = new Subscriptions(_this);
    }return _this;
  }_createClass(Api, [{ key: 'newContract', value: function newContract(







































































    abi, address) {
      return new Contract(this, abi).at(address);
    } }, { key: 'subscribe', value: function subscribe(

    subscriptionName, callback) {
      if (!this._subscriptions) {
        return Promise.resolve(1);
      }

      return this._subscriptions.subscribe(subscriptionName, callback);
    } }, { key: 'unsubscribe', value: function unsubscribe(

    subscriptionId) {
      if (!this._subscriptions) {
        return Promise.resolve(true);
      }

      return this._subscriptions.unsubscribe(subscriptionId);
    } }, { key: 'pollMethod', value: function pollMethod(

    method, input, validate) {var _this2 = this;var _method$split =
      method.split('_'),_method$split2 = _slicedToArray(_method$split, 2),_group = _method$split2[0],endpoint = _method$split2[1];
      var group = '_' + _group;

      return new Promise(function (resolve, reject) {
        var timeout = function timeout() {
          _this2[group][endpoint](input).
          then(function (result) {
            if (validate ? validate(result) : result) {
              resolve(result);
            } else {
              setTimeout(timeout, 500);
            }
          }).
          catch(function (error) {
            // Don't print if the request is rejected: that's ok
            if (error.type !== 'REQUEST_REJECTED') {
              console.error('pollMethod', error);
            }

            reject(error);
          });
        };

        timeout();
      });
    } }, { key: 'isConnected', get: function get() {var isConnected = this.provider.isConnected;return isConnected || typeof isConnected === 'undefined';} }, { key: 'isPubSub', get: function get() {return !!this._pubsub;} }, { key: 'pubsub', get: function get() {if (!this.isPubSub) {throw Error('Pubsub is only available with a subscribing-supported transport injected!');}return this._pubsub;} }, { key: 'db', get: function get() {return this._db;} }, { key: 'eth', get: function get() {return this._eth;} }, { key: 'parity', get: function get() {return this._parity;} }, { key: 'net', get: function get() {return this._net;} }, { key: 'personal', get: function get() {return this._personal;} }, { key: 'provider', get: function get() {return this._provider.provider;} }, { key: 'shell', get: function get() {return this._shell;} }, { key: 'shh', get: function get() {return this._shh;} }, { key: 'signer', get: function get() {return this._signer;} }, { key: 'trace', get: function get() {return this._trace;} }, { key: 'transport', get: function get() {return this.provider;} }, { key: 'web3', get: function get() {return this._web3;} }, { key: 'util', get: function get() {return util;} }]);return Api;}(EventEmitter);


Api.util = util;

Api.Provider = {
  Current: Providers.Current,
  Http: Providers.Http,
  PostMessage: Providers.PostMessage,
  SendAsync: Providers.SendAsync,
  Ws: Providers.Ws,
  WsSecure: Providers.WsSecure };


// NOTE: kept for backwards compatibility
Api.Transport = {
  Http: Transports.Http,
  Ws: Transports.Ws,
  WsSecure: Transports.WsSecure };


module.exports = Api;
'use strict';var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self, call) {if (!self) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call && (typeof call === "object" || typeof call === "function") ? call : self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;} // Copyright 2015-2017 Parity Technologies (UK) Ltd.
// This file is part of Parity.

// Parity is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity.  If not, see <http://www.gnu.org/licenses/>.

require('./polyfill');var _require =

require('js-sha3'),keccak_256 = _require.keccak_256; // eslint-disable-line camelcase
var _require2 =
require('../../subscriptions'),Logging = _require2.Logging;
var JsonRpcBase = require('../jsonRpcBase');
var TransportError = require('../error');

/* global WebSocket */var
Ws = function (_JsonRpcBase) {_inherits(Ws, _JsonRpcBase);
  // token is optional (secure API)
  function Ws(url) {var token = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;var autoconnect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;_classCallCheck(this, Ws);var _this = _possibleConstructorReturn(this, (Ws.__proto__ || Object.getPrototypeOf(Ws)).call(this));


    _this._url = url;
    _this._token = token;
    _this._messages = {};
    _this._subscriptions = {};
    _this._sessionHash = null;

    _this._connecting = false;
    _this._connected = false;
    _this._lastError = null;
    _this._autoConnect = autoconnect;
    _this._retries = 0;
    _this._reconnectTimeoutId = null;

    _this._connectPromise = null;
    _this._connectPromiseFunctions = {};

    _this._onClose = _this._onClose.bind(_this);
    _this._onError = _this._onError.bind(_this);
    _this._onMessage = _this._onMessage.bind(_this);
    _this._onOpen = _this._onOpen.bind(_this);
    _this._extract = _this._extract.bind(_this);
    _this._send = _this._send.bind(_this);

    if (autoconnect) {
      _this.connect();
    }return _this;
  }_createClass(Ws, [{ key: 'updateToken', value: function updateToken(

    token) {var connect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this._token = token;
      // this._autoConnect = true;

      if (connect) {
        this.connect();
      }
    } }, { key: 'connect', value: function connect()

    {var _this2 = this;
      if (this._connected) {
        return Promise.resolve();
      }

      if (this._connecting) {
        return this._connectPromise || Promise.resolve();
      }

      if (this._reconnectTimeoutId) {
        window.clearTimeout(this._reconnectTimeoutId);
        this._reconnectTimeoutId = null;
      }

      if (this._ws) {
        this._ws.onerror = null;
        this._ws.onopen = null;
        this._ws.onclose = null;
        this._ws.onmessage = null;
        this._ws.close();
        this._ws = null;
        this._sessionHash = null;
      }
      this._connecting = true;
      this._connected = false;
      this._lastError = null;

      // rpc secure API
      if (this._token) {
        var time = parseInt(new Date().getTime() / 1000, 10);
        var sha3 = keccak_256(this._token + ':' + time);
        var hash = sha3 + '_' + time;

        this._sessionHash = sha3;
        this._ws = new WebSocket(this._url, hash);
        // non-secure API
      } else {
        this._ws = new WebSocket(this._url);
      }

      this._ws.onerror = this._onError;
      this._ws.onopen = this._onOpen;
      this._ws.onclose = this._onClose;
      this._ws.onmessage = this._onMessage;

      // Get counts in dev mode only
      if (process.env.NODE_ENV === 'development') {
        this._count = 0;
        this._lastCount = {
          timestamp: Date.now(),
          count: 0 };


        window.setInterval(function () {
          var n = _this2._count - _this2._lastCount.count;
          var t = (Date.now() - _this2._lastCount.timestamp) / 1000;
          var s = Math.round(1000 * n / t) / 1000;

          if (_this2._debug) {
            console.log('::parityWS', 'speed: ' + s + ' req/s', 'count: ' + _this2._count, '(+' + n + ')');
          }

          _this2._lastCount = {
            timestamp: Date.now(),
            count: _this2._count };

        }, 5000);

        window._parityWS = this;
      }

      this._connectPromise = new Promise(function (resolve, reject) {
        _this2._connectPromiseFunctions = { resolve: resolve, reject: reject };
      });

      return this._connectPromise;
    } }, { key: '_onOpen', value: function _onOpen(

    event) {var _this3 = this;
      this._setConnected();
      this._connecting = false;
      this._retries = 0;

      Object.keys(this._messages).
      filter(function (id) {return _this3._messages[id].queued;}).
      forEach(this._send);

      this._connectPromiseFunctions.resolve();

      this._connectPromise = null;
      this._connectPromiseFunctions = {};
    } }, { key: '_onClose', value: function _onClose(

    event) {var _this4 = this;
      this._setDisconnected();
      this._connecting = false;

      event.timestamp = Date.now();
      this._lastError = event;

      if (this._autoConnect) {
        var timeout = this.retryTimeout;

        var time = timeout < 1000 ?
        Math.round(timeout) + 'ms' :
        Math.round(timeout / 10) / 100 + 's';

        console.log('ws:onClose', 'trying again in ' + time + '...');

        this._reconnectTimeoutId = setTimeout(function () {
          _this4.connect();
        }, timeout);

        return;
      }

      if (this._connectPromise) {
        this._connectPromiseFunctions.reject(event);

        this._connectPromise = null;
        this._connectPromiseFunctions = {};
      }

      console.log('ws:onClose');
    } }, { key: '_onError', value: function _onError(

    event) {var _this5 = this;
      // Only print error if the WS is connected
      // ie. don't print if error == closed
      window.setTimeout(function () {
        if (_this5._connected) {
          console.error('ws:onError');

          event.timestamp = Date.now();
          _this5._lastError = event;

          if (_this5._connectPromise) {
            _this5._connectPromiseFunctions.reject(event);

            _this5._connectPromise = null;
            _this5._connectPromiseFunctions = {};
          }
        }
      }, 50);
    } }, { key: '_extract', value: function _extract(

    result) {var
      res = result.result,id = result.id,method = result.method,params = result.params;
      var msg = this._messages[id];

      // initial pubsub ACK
      if (id && msg.subscription) {
        // save subscription to map subId -> messageId
        this._subscriptions[msg.subscription] = this._subscriptions[msg.subscription] || {};
        this._subscriptions[msg.subscription][res] = id;
        // resolve promise with messageId because subId's can collide (eth/parity)
        msg.resolve(id);
        // save subId for unsubscribing later
        msg.subId = res;
        return msg;
      }

      // normal message
      if (id) {
        return msg;
      }

      // pubsub format
      if (this._subscriptions[method]) {
        var messageId = this._messages[this._subscriptions[method][params.subscription]];

        if (messageId) {
          return messageId;
        } else {
          throw Error('Received Subscription which is already unsubscribed ' + JSON.stringify(result));
        }
      }

      throw Error('Unknown message format: No ID or subscription ' + JSON.stringify(result));
    } }, { key: '_onMessage', value: function _onMessage(

    event) {
      try {
        var result = JSON.parse(event.data);var _extract2 =
        this._extract(result),method = _extract2.method,params = _extract2.params,json = _extract2.json,resolve = _extract2.resolve,reject = _extract2.reject,callback = _extract2.callback,subscription = _extract2.subscription;

        Logging.send(method, params, { json: json, result: result });

        result.error = result.params && result.params.error || result.error;
        if (result.error) {
          this.error(event.data);

          // Don't print error if request rejected or not is not yet up...
          if (!/(rejected|not yet up)/.test(result.error.message)) {
            console.error(method + '(' + JSON.stringify(params) + '): ' + result.error.code + ': ' + result.error.message);
          }

          var error = new TransportError(method, result.error.code, result.error.message);

          if (result.id) {
            reject(error);
          } else {
            callback(error);
          }

          delete this._messages[result.id];
          return;
        }

        // if not initial subscription message resolve & delete
        if (result.id && !subscription) {
          resolve(result.result);
          delete this._messages[result.id];
        } else if (result.params) {
          callback(null, result.params.result);
        }
      } catch (e) {
        console.error('ws::_onMessage', event.data, e);
      }
    } }, { key: '_send', value: function _send(

    id) {
      var message = this._messages[id];

      if (this._connected) {
        if (process.env.NODE_ENV === 'development') {
          this._count++;
        }

        return this._ws.send(message.json);
      }

      message.queued = !this._connected;
      message.timestamp = Date.now();
    } }, { key: '_execute', value: function _execute(

    method, params) {var _this6 = this;
      return new Promise(function (resolve, reject) {
        var id = _this6.id;
        var json = _this6.encode(method, params);

        _this6._messages[id] = { id: id, method: method, params: params, json: json, resolve: resolve, reject: reject };
        _this6._send(id);
      });
    } }, { key: '_methodsFromApi', value: function _methodsFromApi(

    api) {
      if (api.subscription) {var
        subscribe = api.subscribe,unsubscribe = api.unsubscribe,subscription = api.subscription;

        return {
          method: subscribe,
          uMethod: unsubscribe,
          subscription: subscription };

      }

      return {
        method: api + '_subscribe',
        uMethod: api + '_unsubscribe',
        subscription: api + '_subscription' };

    } }, { key: 'subscribe', value: function subscribe(

    api, callback, params) {var _this7 = this;
      return new Promise(function (resolve, reject) {
        var id = _this7.id;var _methodsFromApi2 =
        _this7._methodsFromApi(api),method = _methodsFromApi2.method,uMethod = _methodsFromApi2.uMethod,subscription = _methodsFromApi2.subscription;
        var json = _this7.encode(method, params);

        _this7._messages[id] = { id: id, method: method, uMethod: uMethod, params: params, json: json, resolve: resolve, reject: reject, callback: callback, subscription: subscription };

        _this7._send(id);
      });
    } }, { key: 'unsubscribe', value: function unsubscribe(

    messageId) {var _this8 = this;
      return new Promise(function (resolve, reject) {
        var id = _this8.id;var _messages$messageId =
        _this8._messages[messageId],subId = _messages$messageId.subId,uMethod = _messages$messageId.uMethod,subscription = _messages$messageId.subscription;
        var params = [subId];
        var json = _this8.encode(uMethod, params);
        var uResolve = function uResolve(v) {
          delete _this8._messages[messageId];
          delete _this8._subscriptions[subscription][subId];
          resolve(v);
        };

        _this8._messages[id] = { id: id, method: uMethod, params: params, json: json, resolve: uResolve, reject: reject };
        _this8._send(id);
      });
    } }, { key: 'unsubscribeAll', value: function unsubscribeAll()

    {var _this9 = this;
      return new Promise(function (resolve, reject) {
        var unsubscribed = 0;
        var keys = Object.keys(_this9._messages);

        keys.forEach(function (i) {return _this9._messages[i].subscription ? _this9.unsubscribe(_this9._messages[i].subId).then(function (_) {return unsubscribed++;}, reject) : null;});
        resolve(unsubscribed);
      });
    } }, { key: 'url', set: function set(

    url) {
      this._url = url;
    } }, { key: 'token', get: function get()

    {
      return this._token;
    } }, { key: 'sessionHash', get: function get()

    {
      return this._sessionHash;
    } }, { key: 'isAutoConnect', get: function get()

    {
      return this._autoConnect;
    } }, { key: 'isConnecting', get: function get()

    {
      return this._connecting;
    } }, { key: 'lastError', get: function get()

    {
      return this._lastError;
    }

    /**
       * Exponential Timeout for Retries
       *
       * @see http://dthain.blogspot.de/2009/02/exponential-backoff-in-distributed.html
       */ }, { key: 'retryTimeout', get: function get()
    {
      // R between 1 and 2
      var R = Math.random() + 1;
      // Initial timeout (100ms)
      var T = 100;
      // Exponential Factor
      var F = 2;
      // Max timeout (4s)
      var M = 4000;
      // Current number of retries
      var N = this._retries;

      // Increase retries number
      this._retries++;

      return Math.min(R * T * Math.pow(F, N), M);
    } }]);return Ws;}(JsonRpcBase);


module.exports = Ws;
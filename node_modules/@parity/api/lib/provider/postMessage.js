'use strict';var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self, call) {if (!self) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call && (typeof call === "object" || typeof call === "function") ? call : self;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;} // Copyright 2015-2017 Parity Technologies (UK) Ltd.
// This file is part of Parity.

// Parity is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity.  If not, see <http://www.gnu.org/licenses/>.

var EventEmitter = require('eventemitter3');

var METHOD_REQUEST_TOKEN = 'shell_requestNewToken';var

PostMessage = function (_EventEmitter) {_inherits(PostMessage, _EventEmitter);
  function PostMessage(appId, destination, source) {_classCallCheck(this, PostMessage);var _this = _possibleConstructorReturn(this, (PostMessage.__proto__ || Object.getPrototypeOf(PostMessage)).call(this));


    _this._appId = appId;
    _this._destination = destination || window.parent;

    _this.id = 0;
    _this._connected = false;
    _this._messages = {};
    _this._queued = [];

    _this._receiveMessage = _this._receiveMessage.bind(_this);
    _this._send = _this._send.bind(_this);
    _this.send = _this.send.bind(_this);
    _this.subscribe = _this.subscribe.bind(_this);
    _this.unsubscribe = _this.unsubscribe.bind(_this);

    (source || window).addEventListener('message', _this._receiveMessage, false);return _this;
  }_createClass(PostMessage, [{ key: 'setToken', value: function setToken(













    token) {
      if (token) {
        this._connected = true;
        this._token = token;
        this.emit('connected');
        this._sendQueued();
      }
    } }, { key: 'addMiddleware', value: function addMiddleware()

    {
    } }, { key: 'requestNewToken', value: function requestNewToken()

    {var _this2 = this;
      return new Promise(function (resolve, reject) {
        _this2.send(METHOD_REQUEST_TOKEN, [], function (error, token) {
          if (error) {
            reject(error);
          } else {
            _this2.setToken(token);
            resolve(token);
          }
        });
      });
    } }, { key: '_constructMessage', value: function _constructMessage(

    id, data) {
      return Object.assign({}, data, {
        id: id,
        to: 'shell',
        from: this._appId,
        token: this._token });

    } }, { key: '_send', value: function _send(

    message) {
      if (!this._token && message.data.method !== METHOD_REQUEST_TOKEN) {
        this._queued.push(message);

        return;
      }

      var id = ++this.id;
      var postMessage = this._constructMessage(id, message.data);

      this._messages[id] = Object.assign({}, postMessage, message.options);
      this._destination.postMessage(postMessage, '*');
    } }, { key: 'send', value: function send(

    method, params, callback) {
      this._send({
        data: {
          method: method,
          params: params },

        options: {
          callback: callback } });


    } }, { key: '_sendQueued', value: function _sendQueued()

    {
      if (!this._token) {
        return;
      }

      this._queued.forEach(this._send);
      this._queued = [];
    } }, { key: 'subscribe', value: function subscribe(

    api, callback, params) {var _this3 = this;
      // console.log('paritySubscribe', JSON.stringify(params), api, callback);
      return new Promise(function (resolve, reject) {
        _this3._send({
          data: {
            api: api,
            params: params },

          options: {
            callback: callback,
            resolve: resolve,
            reject: reject,
            subscription: true,
            initial: true } });


      });
    }

    // FIXME: Should return callback, not promise
  }, { key: 'unsubscribe', value: function unsubscribe(subId) {var _this4 = this;
      return new Promise(function (resolve, reject) {
        _this4._send({
          data: {
            subId: subId },

          options: {
            callback: function callback(error, result) {
              error ?
              reject(error) :
              resolve(result);
            } } });


      });
    } }, { key: 'unsubscribeAll', value: function unsubscribeAll()

    {
      return this.unsubscribe('*');
    } }, { key: '_receiveMessage', value: function _receiveMessage(_ref)

    {var _ref$data = _ref.data,id = _ref$data.id,error = _ref$data.error,from = _ref$data.from,to = _ref$data.to,token = _ref$data.token,result = _ref$data.result,origin = _ref.origin,source = _ref.source;
      var isTokenValid = token ?
      token === this._token :
      true;

      if (from !== 'shell' || to !== this._appId || !isTokenValid) {
        return;
      }

      if (this._messages[id].subscription) {
        // console.log('subscription', result, 'initial?', this._messages[id].initial);
        this._messages[id].initial ?
        this._messages[id].resolve(result) :
        this._messages[id].callback(error && new Error(error), result);
        this._messages[id].initial = false;
      } else {
        this._messages[id].callback(error && new Error(error), result);
        this._messages[id] = null;
      }
    } }, { key: 'isConnected', get: function get() {return this._connected;} }, { key: 'isParity', get: function get() {return true;} }, { key: 'queuedCount', get: function get() {return this._queued.length;} }]);return PostMessage;}(EventEmitter);


module.exports = PostMessage;